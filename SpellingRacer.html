<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spelling Racer: Drift & Spell</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Face Mesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <!-- Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Racing+Sans+One&family=Roboto:wght@400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            background-color: #1e293b;
            user-select: none;
        }

        .title-font {
            font-family: 'Racing Sans One', cursive;
        }

        #game-container {
            perspective: 800px;
            overflow: hidden;
        }

        .mirror {
            transform: scaleX(-1);
        }

        .crash-effect {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(8px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }

        /* Custom Scrollbar */
        textarea::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track { background: #334155; border-radius: 4px; }
        textarea::-webkit-scrollbar-thumb { background: #facc15; border-radius: 4px; }

        .car-option {
            transition: all 0.2s;
            border: 3px solid transparent;
        }
        .car-option.selected {
            border-color: #facc15; /* Yellow border */
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(250, 204, 21, 0.6);
            z-index: 10;
        }

        /* Fixed Difficulty Buttons */
        .diff-btn {
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 700;
            transition: all 0.2s;
            border: 2px solid transparent;
            cursor: pointer;
            background-color: #1e293b; /* bg-slate-800 */
            color: #94a3b8; /* text-slate-400 */
        }
        .diff-btn:hover {
            color: #ffffff;
        }
        .diff-btn.selected {
            border-color: #3b82f6; /* Blue border */
            color: #3b82f6; /* Blue text */
            background-color: #334155; /* bg-slate-700 */
        }
    </style>
</head>
<body class="h-screen w-full bg-slate-900 text-white flex flex-col transition-colors duration-500" id="main-body">

    <!-- SETUP SCREEN -->
    <div id="setup-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-slate-900/95 p-4 overflow-y-auto backdrop-blur-md">
        <div class="max-w-4xl w-full flex flex-col md:flex-row gap-6 items-center justify-center">
            
            <!-- Left: Settings -->
            <div class="w-full max-w-md bg-slate-800 p-6 rounded-2xl shadow-2xl border border-slate-700">
                <h1 class="text-5xl text-yellow-400 title-font mb-2 tracking-wider italic text-center">SPELLING RACER</h1>
                <p class="text-slate-400 mb-4 text-center text-xs uppercase tracking-widest">Tilt Head Left/Right to Steer</p>
                
                <div class="flex gap-4 mb-4">
                    <div class="flex-1">
                        <label class="block text-xs font-bold text-slate-400 mb-1 uppercase">Word List</label>
                        <textarea id="word-input" class="w-full h-24 bg-slate-900 text-white p-3 rounded-xl border border-slate-600 focus:border-yellow-400 focus:ring-1 focus:ring-yellow-400 outline-none resize-none font-mono text-sm placeholder-slate-600" placeholder="necessary&#10;believe">necessary
believe
separate
definitely
occurrence
schedule
restaurant
guarantee
receive
beginning</textarea>
                    </div>
                </div>

                <div class="flex flex-col gap-4 mb-6">
                    <!-- Row 1: Car & Difficulty -->
                    <div class="flex justify-between items-end gap-4">
                        <div class="flex-1">
                            <label class="block text-xs font-bold text-slate-400 mb-2 uppercase">Your Car</label>
                            <div class="flex justify-start gap-3 bg-slate-900/50 p-2 rounded-xl border border-slate-700 w-fit">
                                <button onclick="selectCar('#facc15')" class="car-option selected w-8 h-8 rounded bg-yellow-400 shadow-sm" aria-label="Yellow Car"></button>
                                <button onclick="selectCar('#ef4444')" class="car-option w-8 h-8 rounded bg-red-500 shadow-sm" aria-label="Red Car"></button>
                                <button onclick="selectCar('#3b82f6')" class="car-option w-8 h-8 rounded bg-blue-500 shadow-sm" aria-label="Blue Car"></button>
                                <button onclick="selectCar('#22c55e')" class="car-option w-8 h-8 rounded bg-green-500 shadow-sm" aria-label="Green Car"></button>
                            </div>
                        </div>

                        <div>
                            <label class="block text-xs font-bold text-slate-400 mb-2 uppercase text-right">Difficulty</label>
                            <div class="flex bg-slate-900/50 p-1 rounded-lg border border-slate-700 gap-1">
                                <button onclick="setDifficulty('EASY')" id="diff-easy" class="diff-btn selected">EASY</button>
                                <button onclick="setDifficulty('HARD')" id="diff-hard" class="diff-btn">HARD</button>
                            </div>
                        </div>
                    </div>

                    <!-- Row 2: Theme -->
                    <div class="flex justify-end">
                        <div class="flex items-center gap-2">
                            <label class="text-xs font-bold text-slate-400 uppercase">Theme</label>
                            <div class="flex bg-slate-900/50 p-1 rounded-lg border border-slate-700">
                                <button onclick="setTheme('NIGHT')" id="btn-night" class="px-3 py-1 rounded text-xs font-bold bg-slate-600 text-white transition-colors">üåô</button>
                                <button onclick="setTheme('DAY')" id="btn-day" class="px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white transition-colors">‚òÄÔ∏è</button>
                            </div>
                        </div>
                    </div>
                </div>

                <button onclick="initGame()" class="w-full bg-gradient-to-r from-yellow-500 to-orange-600 hover:from-yellow-400 hover:to-orange-500 text-black font-black text-2xl py-3 rounded-xl transition-transform hover:scale-105 shadow-lg uppercase italic border-b-4 border-orange-700 active:border-b-0 active:translate-y-1">
                    Start Engine üèéÔ∏è
                </button>
            </div>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game-ui" class="hidden relative w-full h-full flex flex-col">
        
        <!-- Canvas Layer -->
        <canvas id="gameCanvas" class="absolute inset-0 w-full h-full z-0"></canvas>

        <!-- HUD -->
        <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-20 pointer-events-none">
            <div class="flex gap-4">
                <div class="bg-black/60 backdrop-blur rounded-xl px-6 py-2 border border-white/20">
                    <div class="text-xs text-slate-400 uppercase font-bold">Score</div>
                    <div class="text-4xl title-font text-yellow-400" id="score-display">0</div>
                </div>
                
                <div class="bg-black/60 backdrop-blur rounded-xl px-6 py-2 border border-white/20">
                    <div class="text-xs text-slate-400 uppercase font-bold">Speed</div>
                    <div class="text-4xl title-font text-cyan-400"><span id="speed-display">60</span> <span class="text-sm">MPH</span></div>
                </div>
            </div>

            <!-- Pause Button -->
            <button onclick="togglePause()" class="pointer-events-auto bg-black/60 hover:bg-black/80 backdrop-blur rounded-full w-12 h-12 flex items-center justify-center border border-white/20 transition-colors shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>
        </div>

        <!-- Camera View (Bottom Right) -->
        <div class="absolute bottom-4 right-4 z-30">
            <div class="w-32 h-32 md:w-48 md:h-48 rounded-2xl border-4 border-yellow-400 overflow-hidden shadow-[0_0_20px_rgba(250,204,21,0.5)] bg-slate-800 relative">
                <video id="input_video" class="w-full h-full object-cover mirror"></video>
                <div id="steering-wheel" class="absolute inset-0 border-4 border-white/20 rounded-2xl pointer-events-none">
                    <div class="absolute top-2 left-1/2 transform -translate-x-1/2 bg-red-500 w-1 h-4"></div>
                </div>
            </div>
            <div class="text-center mt-2 font-bold text-yellow-400 bg-black/50 rounded px-2" id="steer-text">CENTER</div>
        </div>

    </div>

    <!-- Pause Modal -->
    <div id="pause-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
        <div class="text-center bg-slate-800 p-8 rounded-2xl border border-slate-600 shadow-2xl">
            <h2 class="text-5xl text-yellow-400 title-font mb-6">PAUSED</h2>
            <div class="flex flex-col gap-4">
                <button onclick="togglePause()" class="px-8 py-3 bg-cyan-500 hover:bg-cyan-600 text-black font-bold text-xl rounded-xl transition-transform hover:scale-105 shadow-lg border-b-4 border-cyan-700 active:border-b-0 active:translate-y-1">
                    RESUME
                </button>
                <button onclick="showSetup()" class="px-8 py-3 bg-slate-600 hover:bg-slate-500 text-white font-bold text-xl rounded-xl transition-transform hover:scale-105 border-b-4 border-slate-800 active:border-b-0 active:translate-y-1">
                    QUIT TO MENU
                </button>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-md p-4">
        <div class="text-center">
            <h2 class="text-6xl text-red-500 title-font mb-2 animate-bounce">CRASHED!</h2>
            <p class="text-xl text-white mb-6">You hit the wrong word!</p>
            <div class="text-8xl mb-6">üí•</div>
            <p class="text-slate-400 mb-8">Final Score: <span id="final-score" class="text-white font-bold text-2xl">0</span></p>
            
            <div class="flex flex-col gap-4">
                <button onclick="resetRace()" class="px-10 py-4 bg-white hover:bg-gray-100 text-black font-black text-xl rounded-full hover:scale-105 transition-transform shadow-lg border-b-4 border-gray-400 active:border-b-0 active:translate-y-1">
                    RACE AGAIN
                </button>
                <button onclick="showSetup()" class="px-10 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold text-lg rounded-full hover:scale-105 transition-transform shadow-lg">
                    EDIT WORDS
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. GAME CONFIG ---
        const LANE_COUNT = 2;
        let SPEED = 5; 
        let GAME_ACTIVE = false;
        let GAME_PAUSED = false;
        let SCORE = 0;
        let LAST_SPAWN = 0;
        let LAST_DECO = 0;
        let LAST_ITEM = 0; 
        let SPAWN_RATE = 2500; 
        let ITEM_RATE = 8000; 
        let PLAYER_COLOR = '#facc15'; 
        let THEME = 'NIGHT'; 
        let SUCCESSFUL_HITS = 0; 
        let DIFFICULTY = 'EASY'; 
        
        // --- 2. STATE ---
        let words = [];
        let playerLane = 0; 
        let targetLane = 0; 
        
        let enemies = []; 
        let decorations = []; 
        let items = []; 
        let fxText = []; // Floating text objects {text, x, y, life, color}
        let screenFlash = { r:0, g:0, b:0, a:0 }; // Canvas based flash

        const CAR_COLORS = [
            '#ef4444', '#f97316', '#f59e0b', '#84cc16', 
            '#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', 
            '#d946ef', '#f43f5e'
        ];

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // --- 3. LOGIC ---
        function generateWrong(word) {
            const len = word.length;
            const arr = word.split('');
            if (len < 2) return word + 's';
            const roll = Math.random();
            const type = Math.floor(Math.random() * 4); 
            let resultArr = [...arr];

            if (type === 0 && len > 2) { 
                const idx = Math.floor(Math.random() * len);
                resultArr.splice(idx, 1);
            } else if (type === 1) { 
                const idx = Math.floor(Math.random() * len);
                const char = arr[idx].toLowerCase();
                const map = { 'a':['e'], 'e':['a','i'], 'i':['e','y'], 'o':['u'], 'u':['o'], 'c':['k','s'], 'k':['c'], 's':['z','c'], 'f':['ph'] };
                let sub = map[char] ? map[char][Math.floor(Math.random()*map[char].length)] : String.fromCharCode(char.charCodeAt(0)+1);
                resultArr[idx] = sub;
            } else if (type === 2) { 
                const idx = Math.floor(Math.random() * len);
                if (resultArr[idx] !== ' ') resultArr.splice(idx, 0, resultArr[idx]);
            } else { 
                if (len > 1) {
                    const idx = Math.floor(Math.random() * (len - 1));
                    const temp = resultArr[idx];
                    resultArr[idx] = resultArr[idx+1];
                    resultArr[idx+1] = temp;
                }
            }
            const res = resultArr.join('');
            return res === word ? generateWrong(word) : res;
        }

        // --- 4. UI FUNCTIONS ---
        function selectCar(color) {
            PLAYER_COLOR = color;
            const btns = document.querySelectorAll('.car-option');
            btns.forEach(btn => {
                if(btn.getAttribute('onclick').includes(color)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        function setDifficulty(diff) {
            DIFFICULTY = diff;
            const easyBtn = document.getElementById('diff-easy');
            const hardBtn = document.getElementById('diff-hard');
            
            if (diff === 'EASY') {
                easyBtn.classList.add('selected');
                hardBtn.classList.remove('selected');
            } else {
                hardBtn.classList.add('selected');
                easyBtn.classList.remove('selected');
            }
        }

        function setTheme(theme) {
            THEME = theme;
            const nightBtn = document.getElementById('btn-night');
            const dayBtn = document.getElementById('btn-day');
            
            if (theme === 'NIGHT') {
                nightBtn.className = "px-3 py-1 rounded text-xs font-bold bg-slate-600 text-white transition-colors";
                dayBtn.className = "px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white transition-colors";
            } else {
                dayBtn.className = "px-3 py-1 rounded text-xs font-bold bg-blue-400 text-white transition-colors";
                nightBtn.className = "px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white transition-colors";
            }
        }

        // --- 5. GAME INITIALIZATION ---
        function initGame() {
            const raw = document.getElementById('word-input').value;
            words = raw.split('\n').map(w => w.trim()).filter(w => w.length > 0);
            
            if (words.length < 1) return alert("Please enter at least 1 word.");

            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            
            if (!window.cameraStarted) {
                startCamera();
                window.cameraStarted = true;
            }
            
            resetRace();
            startGameLoop();
        }

        function resetRace() {
            SCORE = 0;
            SPEED = 5; 
            SPAWN_RATE = 2500; 
            LAST_SPAWN = 0;
            LAST_ITEM = 0;
            SUCCESSFUL_HITS = 0;
            enemies = [];
            decorations = [];
            items = [];
            fxText = [];
            screenFlash = {r:0,g:0,b:0,a:0};
            playerLane = 0;
            targetLane = 0;
            
            GAME_ACTIVE = true;
            GAME_PAUSED = false;
            
            document.getElementById('score-display').innerText = '0';
            document.getElementById('speed-display').innerText = '60';
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('pause-modal').classList.add('hidden');
            document.body.classList.remove('crash-effect');
        }

        function showSetup() {
            GAME_ACTIVE = false;
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('pause-modal').classList.add('hidden');
            document.getElementById('setup-screen').classList.remove('hidden');
        }

        function togglePause() {
            if (!GAME_ACTIVE) return;
            GAME_PAUSED = !GAME_PAUSED;
            if (GAME_PAUSED) {
                document.getElementById('pause-modal').classList.remove('hidden');
            } else {
                document.getElementById('pause-modal').classList.add('hidden');
            }
        }

        // --- 6. MEDIAPIPE CAMERA ---
        async function startCamera() {
            const videoElement = document.getElementById('input_video');
            const faceMesh = new FaceMesh({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }});
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await faceMesh.send({image: videoElement});
                },
                width: 480,
                height: 480
            });
            camera.start();
        }

        function onFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;
            
            const landmarks = results.multiFaceLandmarks[0];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            
            const dx = rightEye.x - leftEye.x;
            const dy = rightEye.y - leftEye.y;
            const angle = Math.atan2(dy, dx) * (180 / Math.PI); 
            
            const wheel = document.getElementById('steering-wheel');
            wheel.style.transform = `rotate(${angle}deg)`;
            
            const threshold = 10; 
            const steerText = document.getElementById('steer-text');

            if (angle > threshold) {
                targetLane = 0; // Left
                steerText.innerText = "<< LEFT";
                steerText.className = "text-center mt-2 font-bold text-cyan-400 bg-black/50 rounded px-2";
            } else if (angle < -threshold) {
                targetLane = 1; // Right
                steerText.innerText = "RIGHT >>";
                steerText.className = "text-center mt-2 font-bold text-cyan-400 bg-black/50 rounded px-2";
            } else {
                steerText.innerText = "CENTER";
                steerText.className = "text-center mt-2 font-bold text-yellow-400 bg-black/50 rounded px-2";
            }
        }

        // --- 7. GAME LOOP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function startGameLoop() {
            if (!window.loopStarted) {
                resize();
                window.addEventListener('resize', resize);
                requestAnimationFrame(update);
                window.loopStarted = true;
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function spawnEnemy() {
            const correctWord = words[Math.floor(Math.random() * words.length)];
            const wrongWord = generateWrong(correctWord);
            const correctLane = Math.random() < 0.5 ? 0 : 1;
            
            const color1 = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)];
            const color2 = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)];

            enemies.push({
                x: 0, 
                y: -100,
                z: 1000, 
                lane: correctLane,
                word: correctWord,
                isCorrect: true,
                color: color1,
                isDead: false,
                vx: 0, vy: 0, rotation: 0, rotationSpeed: 0
            });

            enemies.push({
                x: 0,
                y: -100,
                z: 1000,
                lane: correctLane === 0 ? 1 : 0,
                word: wrongWord,
                isCorrect: false,
                color: color2,
                isDead: false,
                vx: 0, vy: 0, rotation: 0, rotationSpeed: 0
            });
        }

        function spawnItem() {
            const lane = Math.random() < 0.5 ? 0 : 1;
            const type = Math.random() < 0.7 ? 'BONUS' : 'BOMB';
            
            items.push({
                x: 0,
                y: -100,
                z: 1000,
                lane: lane,
                type: type,
                active: true
            });
        }

        function spawnDecoration() {
            // Theme specific decor
            const type = THEME === 'SUNSET' ? 'lamp' : 'tree';
            decorations.push({
                z: 1000,
                side: -1,
                type: Math.random() < 0.3 ? 'bush' : type,
                color: `hsl(${Math.random() * 360}, 60%, 50%)` 
            });
            decorations.push({
                z: 1000,
                side: 1,
                type: Math.random() < 0.3 ? 'bush' : type,
                color: `hsl(${Math.random() * 360}, 60%, 50%)`
            });
        }

        function update(time) {
            if (!GAME_ACTIVE) {
                if (window.loopStarted) requestAnimationFrame(update);
                return;
            }
            if (GAME_PAUSED) {
                requestAnimationFrame(update);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const roadW = canvas.width * 0.6;
            const centerX = canvas.width / 2;
            const horizonY = canvas.height * 0.3;
            
            let skyColor, groundColor, roadColor, lineColor;
            if (THEME === 'NIGHT') {
                skyColor = '#0f172a'; groundColor = '#020617'; roadColor = '#334155'; lineColor = '#ffffff';
            } else {
                skyColor = '#38bdf8'; groundColor = '#4ade80'; roadColor = '#64748b'; lineColor = '#facc15'; 
            }

            // Draw Sky/Ground
            ctx.fillStyle = groundColor; 
            ctx.fillRect(0, horizonY, canvas.width, canvas.height);
            ctx.fillStyle = skyColor;
            ctx.fillRect(0, 0, canvas.width, horizonY);
            
            // Draw Road
            ctx.fillStyle = roadColor;
            ctx.beginPath();
            const horizonRoadWidth = 180; 
            ctx.moveTo(centerX - horizonRoadWidth, horizonY); 
            ctx.lineTo(centerX + horizonRoadWidth, horizonY);
            ctx.lineTo(centerX + roadW/2, canvas.height);
            ctx.lineTo(centerX - roadW/2, canvas.height);
            ctx.fill();
            
            // Moving Lines
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 4;
            ctx.setLineDash([40, 60]);
            ctx.lineDashOffset = -time * (SPEED * 0.1);
            ctx.beginPath();
            ctx.moveTo(centerX, horizonY);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Spawn Cars
            if (time - LAST_SPAWN > SPAWN_RATE) {
                spawnEnemy();
                LAST_SPAWN = time;
            }

            // Spawn Items
            if (time - LAST_ITEM > ITEM_RATE && Math.abs(time - LAST_SPAWN) > 1000) {
                spawnItem();
                LAST_ITEM = time;
            }

            // Spawn Decorations
            if (time - LAST_DECO > (5000 / SPEED)) { 
                spawnDecoration();
                LAST_DECO = time;
            }

            // Player Pos
            playerLane += (targetLane - playerLane) * 0.1;
            const laneOffset = (playerLane - 0.5) * (roadW / 2);
            const pX = centerX + laneOffset;
            const pY = canvas.height - 120;

            // DRAW DECORATIONS
            for (let i = decorations.length - 1; i >= 0; i--) {
                let d = decorations[i];
                d.z -= SPEED;
                if (d.z < 0) {
                    decorations.splice(i, 1);
                    continue;
                }
                const progress = (1000 - d.z) / 1000;
                const visualRoadW = horizonRoadWidth*2 + (roadW - horizonRoadWidth*2) * Math.pow(progress, 2); 
                const xOffset = d.side === -1 ? -visualRoadW/1.5 : visualRoadW/1.5; 
                const screenX = centerX + xOffset;
                const screenY = horizonY + (canvas.height - horizonY) * progress;
                const scale = 0.5 + 2.0 * progress;
                drawDecoration(screenX, screenY, scale, d.type, d.color);
            }

            // DRAW ITEMS
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (!item.active) {
                    items.splice(i, 1);
                    continue;
                }
                
                item.z -= SPEED;
                const progress = (1000 - item.z) / 1000;
                if (progress >= 1.2) {
                    items.splice(i, 1);
                    continue;
                }

                const currentRoadW = horizonRoadWidth*2 + (roadW - horizonRoadWidth*2) * Math.pow(progress, 2); 
                const laneX = item.lane === 0 ? -currentRoadW/4 : currentRoadW/4;
                const screenX = centerX + laneX;
                const screenY = horizonY + (canvas.height - horizonY) * progress;
                const scale = 0.5 + 1.5 * progress;

                // Collision
                const playerVisualP = (pY - horizonY) / (canvas.height - horizonY);
                const hitStart = playerVisualP - 0.05;
                const hitEnd = playerVisualP + 0.05;

                if (progress > hitStart && progress < hitEnd) {
                    if (Math.abs(playerLane - item.lane) < 0.3) {
                        hitItem(item);
                        items.splice(i, 1);
                        continue;
                    }
                }

                drawItem(screenX, screenY, scale, item.type);
            }

            // Draw Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (e.isDead) {
                    e.x += e.vx;
                    e.y += e.vy;
                    e.vy += 1; 
                    e.rotation += e.rotationSpeed;
                    drawCar(e.x, e.y, e.lastScale || 1, e.word, e.color, e.rotation);
                    if (e.y > canvas.height + 100) enemies.splice(i, 1);
                    continue;
                }

                e.z -= SPEED; 
                const progress = (1000 - e.z) / 1000; 
                if (progress >= 1.2) {
                    enemies.splice(i, 1);
                    continue;
                }

                const currentRoadW = horizonRoadWidth*2 + (roadW - horizonRoadWidth*2) * Math.pow(progress, 2); 
                const laneX = e.lane === 0 ? -currentRoadW/4 : currentRoadW/4;
                const screenX = centerX + laneX;
                const screenY = horizonY + (canvas.height - horizonY) * progress;
                const scale = 0.5 + 1.5 * progress;
                e.x = screenX; e.y = screenY; e.lastScale = scale;

                // Collision
                const playerVisualP = (pY - horizonY) / (canvas.height - horizonY);
                const hitStart = playerVisualP - 0.05;
                const hitEnd = playerVisualP + 0.05;

                if (progress > hitStart && progress < hitEnd) {
                    if (Math.abs(playerLane - e.lane) < 0.3) {
                        if (e.isCorrect) {
                            hitCorrect(e, screenX, screenY);
                            continue;
                        } else {
                            gameOver();
                        }
                    }
                }
                drawCar(screenX, screenY, scale, e.word, e.color, 0);
            }

            drawPlayerCar(pX, pY);

            // Draw FX Layers
            // Screen Flash
            if (screenFlash.a > 0) {
                ctx.fillStyle = `rgba(${screenFlash.r}, ${screenFlash.g}, ${screenFlash.b}, ${screenFlash.a})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                screenFlash.a -= 0.02; // Fade out
            }

            // Floating Text
            for (let i = fxText.length - 1; i >= 0; i--) {
                let ft = fxText[i];
                ft.y -= 2; // Float up
                ft.life -= 0.02; // Fade out
                
                if (ft.life <= 0) {
                    fxText.splice(i, 1);
                    continue;
                }

                ctx.save();
                ctx.globalAlpha = ft.life;
                ctx.fillStyle = ft.color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.font = `bold ${60}px 'Racing Sans One', sans-serif`; // Use big racing font
                ctx.textAlign = 'center';
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }

            requestAnimationFrame(update);
        }

        function checkSpeedIncrease() {
            let hitsNeeded = 1;
            if (DIFFICULTY === 'EASY') hitsNeeded = 2;
            
            if (SUCCESSFUL_HITS > 0 && SUCCESSFUL_HITS % hitsNeeded === 0) {
                SPEED += 0.8;
                if (SPAWN_RATE > 800) SPAWN_RATE -= 150;
                document.getElementById('speed-display').innerText = Math.round(60 + SPEED * 10);
            }
        }

        function hitItem(item) {
            if (item.type === 'BONUS') {
                SCORE += 300;
                playSynth('success');
                
                // Set Canvas FX
                screenFlash = {r:250, g:204, b:21, a:0.4}; // Gold flash
                fxText.push({
                    text: "+300", 
                    x: canvas.width / 2, 
                    y: canvas.height * 0.3, // Near top center
                    life: 1.0, 
                    color: '#facc15'
                });

                confetti({
                    particleCount: 15,
                    spread: 30,
                    origin: { y: 0.7 },
                    colors: ['#facc15', '#fbbf24'],
                    disableForReducedMotion: true
                });
            } else {
                // BOMB
                SCORE = Math.max(0, SCORE - 100);
                playSynth('bomb');
                
                screenFlash = {r:239, g:68, b:68, a:0.5}; // Red flash
                fxText.push({
                    text: "-100", 
                    x: canvas.width / 2, 
                    y: canvas.height * 0.3, 
                    life: 1.0, 
                    color: '#ef4444'
                });

                confetti({
                    particleCount: 20,
                    spread: 100,
                    startVelocity: 20,
                    origin: { y: 0.7 },
                    colors: ['#1f2937', '#ef4444'],
                    disableForReducedMotion: true
                });
            }
            document.getElementById('score-display').innerText = SCORE;
        }

        function drawItem(x, y, scale, type) {
            ctx.save();
            ctx.translate(x, y);
            const size = 30 * scale;
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, size, size, size/3, 0, 0, Math.PI*2);
            ctx.fill();

            if (type === 'BONUS') {
                ctx.fillStyle = '#facc15'; 
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = `${size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("‚òÖ", 0, 2);
            } else {
                ctx.fillStyle = '#1e293b'; 
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#f87171';
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.quadraticCurveTo(size/2, -size*1.5, size, -size);
                ctx.stroke();
                ctx.fillStyle = '#ef4444';
                ctx.font = `${size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("üí£", 0, 2);
            }
            ctx.restore();
        }

        function drawDecoration(x, y, scale, type, color) {
            ctx.save();
            ctx.translate(x, y);
            
            if (type === 'lamp') {
                ctx.fillStyle = '#64748b';
                const w = 5 * scale;
                const h = 80 * scale;
                ctx.fillRect(-w/2, -h, w, h);
                ctx.fillStyle = '#fef08a'; 
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#fef08a';
                ctx.beginPath();
                ctx.arc(0, -h, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'tree') {
                ctx.fillStyle = '#78350f';
                const w = 10 * scale;
                const h = 40 * scale;
                ctx.fillRect(-w/2, -h, w, h);
                ctx.fillStyle = '#15803d';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(0, -h * 1.5, 30 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = color;
                for(let i=0; i<5; i++) {
                    const fx = (Math.random() - 0.5) * 40 * scale;
                    const fy = (-h * 1.5) + (Math.random() - 0.5) * 40 * scale;
                    ctx.beginPath();
                    ctx.arc(fx, fy, 4 * scale, 0, Math.PI*2);
                    ctx.fill();
                }
            } else {
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(0, 0, 15 * scale, Math.PI, 0); 
                ctx.fill();
                ctx.fillStyle = color;
                for(let i=0; i<3; i++) {
                    const fx = (Math.random() - 0.5) * 20 * scale;
                    const fy = (Math.random() - 0.5) * 10 * scale;
                    ctx.beginPath();
                    ctx.arc(fx, fy - 5*scale, 3 * scale, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function drawCar(x, y, scale, text, color, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.font = `bold ${Math.max(14, 20 * scale)}px Roboto`;
            const metrics = ctx.measureText(text);
            const textW = metrics.width;
            const w = Math.max(80 * scale, textW + (30 * scale));
            const h = 40 * scale;

            if (rotation === 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, h/2 + 5*scale, w/2 + 5*scale, h/4, 0, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(-w/2, -h/2, w, h, 8 * scale);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(-w/2, -h/2, w, h/4);

            ctx.fillStyle = '#ffffff'; 
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 3 * scale;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(text, 0, 2 * scale);
            ctx.fillText(text, 0, 2 * scale);

            ctx.restore();
        }

        function drawPlayerCar(x, y) {
            const w = 120;
            const h = 60;
            ctx.save();
            ctx.translate(x, y);
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.ellipse(0, h/2 + 5, w/2 + 5, h/4, 0, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = PLAYER_COLOR; 
            ctx.beginPath();
            ctx.roundRect(-w/2, -h/2, w, h, 15);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(-w/6, -h/2, w/3, h);

            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(-w/2 - 5, h/2 - 10, w + 10, 12);

            ctx.fillStyle = 'white';
            ctx.font = "bold 20px Roboto";
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 3;
            ctx.textAlign = 'center';
            ctx.strokeText("YOU", 0, 0);
            ctx.fillText("YOU", 0, 0);

            ctx.restore();
        }

        function hitCorrect(enemy, x, y) {
            SCORE += 100;
            SUCCESSFUL_HITS++;
            checkSpeedIncrease();
            document.getElementById('score-display').innerText = SCORE;
            
            enemy.isDead = true;
            enemy.vx = (Math.random() - 0.5) * 30; 
            enemy.vy = -15 - Math.random() * 10; 
            enemy.rotation = 0;
            enemy.rotationSpeed = (Math.random() - 0.5) * 0.5;

            confetti({
                particleCount: 30,
                spread: 50,
                origin: { x: x / canvas.width, y: y / canvas.height },
                colors: ['#facc15', '#ffffff'] 
            });
            
            playSynth('success');
        }

        function gameOver() {
            GAME_ACTIVE = false;
            document.getElementById('final-score').innerText = SCORE;
            document.getElementById('game-over').classList.remove('hidden');
            document.body.classList.add('crash-effect');
            playSynth('crash');
        }

        function playSynth(type) {
            const ctx = audioCtx;
            if (!ctx) return;

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);

            if (type === 'success') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } else if (type === 'bomb') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
                osc.start();
                osc.stop(ctx.currentTime + 0.3);
            } else {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(20, ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                osc.start();
                osc.stop(ctx.currentTime + 0.5);
            }
        }

        window.addEventListener('resize', resize);

    </script>
</body>
</html>
