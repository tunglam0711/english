import React, { useState, useEffect, useRef, useCallback } from 'react';
import confetti from 'canvas-confetti';

// --- Constants ---
const BLOCK_HEIGHT = 80;
const START_SPEED = 3;
const GRAVITY = 25;
const TOPPLE_THRESHOLD = 0.4;
const P1_COLORS = ['#f87171', '#fb923c', '#fbbf24', '#facc15', '#e879f9'];
const P2_COLORS = ['#34d399', '#22d3ee', '#818cf8', '#60a5fa', '#a78bfa'];
const SOLO_COLORS = ['#f87171', '#fb923c', '#fbbf24', '#a3e635', '#34d399', '#22d3ee', '#818cf8', '#e879f9'];

// --- Block Class ---
class Block {
  constructor(x, y, w, color, score, width) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = BLOCK_HEIGHT;
    this.color = color;
    this.swingRange = 250 + Math.random() * 450;
    
    // Difficulty Scaling
    if (score <= 4) {
      this.speed = START_SPEED + score * 0.2;
    } else {
      const diff = score - 4;
      this.speed = START_SPEED + 1.5 + diff * 0.4;
    }

    this.direction = Math.random() < 0.5 ? 1 : -1;
    this.angle = 0;
    this.isBase = false;
  }

  updateSwing(width) {
    this.x += this.speed * this.direction;
    const center = width / 2;
    const halfSwing = this.swingRange / 2;
    const blockHalf = this.w / 2;
    const minX = center - halfSwing - blockHalf;
    const maxX = center + halfSwing - blockHalf;

    if (this.x > maxX) {
      this.x = maxX;
      this.direction = -1;
    } else if (this.x < minX) {
      this.x = minX;
      this.direction = 1;
    }
  }

  draw(ctx, cameraY) {
    ctx.save();
    const drawY = this.y - cameraY;
    
    if (this.angle !== 0) {
      ctx.translate(this.x + this.w / 2, drawY + this.h / 2);
      ctx.rotate(this.angle);
      ctx.translate(-(this.x + this.w / 2), -(drawY + this.h / 2));
    }

    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, drawY, this.w, this.h);

    if (this.angle === 0) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      const windowSize = 12;
      const gap = 10;
      const cols = this.w > 100 ? 4 : 3;

      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < cols; c++) {
          ctx.fillRect(
            this.x + 10 + c * (windowSize + gap),
            drawY + 10 + r * (windowSize + gap),
            windowSize,
            windowSize
          );
        }
      }
    }

    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, drawY, this.w, this.h);
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(this.x, drawY, this.w, 6);
    ctx.restore();
  }
}

export default function App() {
  // --- UI State ---
  const [gameState, setGameState] = useState('START'); // START, PLAYING, DROPPING, PAUSED, GAMEOVER
  const [gameMode, setGameMode] = useState('SOLO');
  const [difficulty, setDifficulty] = useState('NORMAL');
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [maxLives, setMaxLives] = useState(3);
  const [micSensitivity, setMicSensitivity] = useState(50);
  const [currentPlayer, setCurrentPlayer] = useState(1);
  const [movesInTurn, setMovesInTurn] = useState(0);
  const [volumeLevel, setVolumeLevel] = useState(0);
  const [gameOverMsg, setGameOverMsg] = useState('');

  // --- Game Engine Refs ---
  const canvasRef = useRef(null);
  const requestRef = useRef();
  const audioCtxRef = useRef(null);
  const analyserRef = useRef(null);
  const dataArrayRef = useRef(null);
  const smoothedVolumeRef = useRef(0);
  const lastClapTimeRef = useRef(0);
  
  const gameData = useRef({
    blocks: [],
    currentBlock: null,
    cameraY: 0,
    shake: 0,
    towerMass: 0,
    stackCenterOfMass: 0,
    cityBuildings: [],
    width: window.innerWidth,
    height: window.innerHeight,
    blockWidth: 80
  });

  // --- Sound Engine ---
  const playSound = (type) => {
    if (!audioCtxRef.current) return;
    const ctx = audioCtxRef.current;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    const now = ctx.currentTime;
    
    switch(type) {
      case 'spawn':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
      case 'drop':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
        break;
      case 'land':
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, now);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
      case 'perfect':
        const osc2 = ctx.createOscillator();
        osc2.connect(gain);
        osc.type = 'sine';
        osc2.type = 'sine';
        osc.frequency.setValueAtTime(523.25, now); // C5
        osc2.frequency.setValueAtTime(659.25, now); // E5
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc2.start(now);
        osc.stop(now + 0.4);
        osc2.stop(now + 0.4);
        break;
      case 'miss':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
        break;
    }
  };

  // --- Audio Logic ---
  const initAudio = async () => {
    if (!audioCtxRef.current) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioCtx.createAnalyser();
        const source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.3;
        
        audioCtxRef.current = audioCtx;
        analyserRef.current = analyser;
        dataArrayRef.current = new Uint8Array(analyser.frequencyBinCount);
      } catch (err) {
        // Fallback for click only mode
        audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        console.warn("Mic access denied. Playing in click-mode.");
      }
    } else if (audioCtxRef.current.state === 'suspended') {
        audioCtxRef.current.resume();
    }
  };

  const checkClap = useCallback(() => {
    const analyser = analyserRef.current;
    if (!analyser) return false;

    const dataArray = dataArrayRef.current;
    analyser.getByteFrequencyData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    let instantVol = sum / dataArray.length;

    if (instantVol < smoothedVolumeRef.current) smoothedVolumeRef.current = instantVol;
    else smoothedVolumeRef.current += (instantVol - smoothedVolumeRef.current) * 0.05;

    setVolumeLevel(Math.min(100, instantVol * 3));

    const triggerOffset = (100 - micSensitivity) * 0.8;
    const dynamicThreshold = smoothedVolumeRef.current + triggerOffset;
    const now = Date.now();

    if (instantVol > dynamicThreshold && instantVol > 10 && now - lastClapTimeRef.current > 400) {
      lastClapTimeRef.current = now;
      return true;
    }
    return false;
  }, [micSensitivity]);

  // --- Game Actions ---
  const spawnBlock = useCallback(() => {
    const { blocks, width, height, blockWidth } = gameData.current;
    const prevBlock = blocks[blocks.length - 1];
    
    let color;
    if (gameMode === 'MULTI') {
      const palette = currentPlayer === 1 ? P1_COLORS : P2_COLORS;
      color = palette[Math.floor(Math.random() * palette.length)];
    } else {
      color = SOLO_COLORS[score % SOLO_COLORS.length];
    }

    const spawnY = prevBlock ? prevBlock.y - 150 : height - 100;
    const newBlock = new Block(0, spawnY, blockWidth, color, score, width);
    newBlock.x = width / 2 - newBlock.swingRange / 2;
    
    gameData.current.currentBlock = newBlock;
    playSound('spawn');
  }, [gameMode, currentPlayer, score]);

  const triggerDrop = useCallback(() => {
    setGameState((prev) => {
        if (prev === 'PLAYING') {
            playSound('drop');
            return 'DROPPING';
        }
        return prev;
    });
  }, []);

  const handleLanding = useCallback(() => {
    const { blocks, currentBlock, towerMass, stackCenterOfMass, width, blockWidth } = gameData.current;
    const prevBlock = blocks[blocks.length - 1];
    
    if (currentBlock.x + currentBlock.w < prevBlock.x || currentBlock.x > prevBlock.x + prevBlock.w) {
      return 'MISS';
    }

    currentBlock.y = prevBlock.y - BLOCK_HEIGHT;
    const blockCenter = currentBlock.x + currentBlock.w / 2;
    const newMass = towerMass + 1;
    const newCoM = (towerMass * stackCenterOfMass + blockCenter) / newMass;
    const baseCenter = width / 2;
    const deviation = newCoM - baseCenter;
    const limit = blockWidth / 2 + 5;

    if (Math.abs(deviation) > limit) return 'TOPPLE';

    gameData.current.towerMass = newMass;
    gameData.current.stackCenterOfMass = newCoM;
    
    const alignment = Math.abs(currentBlock.x - prevBlock.x);
    return alignment < 5 ? 'PERFECT' : 'LANDED';
  }, []);

  const startGame = async () => {
    await initAudio();
    const w = window.innerWidth;
    const h = window.innerHeight;
    const bW = difficulty === 'EASY' ? 120 : 80;

    gameData.current = {
      ...gameData.current,
      width: w,
      height: h,
      blockWidth: bW,
      blocks: [],
      cameraY: 0,
      shake: 0,
      towerMass: 5,
      stackCenterOfMass: w / 2,
    };

    const baseBlock = new Block(w / 2 - bW / 2, h - 100, bW, '#475569', 0, w);
    baseBlock.isBase = true;
    gameData.current.blocks.push(baseBlock);

    setScore(0);
    setLives(maxLives);
    setCurrentPlayer(1);
    setMovesInTurn(0);
    setGameState('PLAYING');
    spawnBlock();
  };

  const checkTurnEnd = useCallback(() => {
    if (gameMode === 'SOLO') {
      spawnBlock();
      setGameState('PLAYING');
      return;
    }

    const nextMoves = movesInTurn + 1;
    if (nextMoves >= 3) {
      setGameState('PAUSED');
    } else {
      setMovesInTurn(nextMoves);
      spawnBlock();
      setGameState('PLAYING');
    }
  }, [gameMode, movesInTurn, spawnBlock]);

  // --- Game Loop ---
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const loop = () => {
      const { width, height, blocks, currentBlock, cameraY, shake, cityBuildings, blockWidth } = gameData.current;
      
      // Resize check
      if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        const oldW = gameData.current.width;
        gameData.current.width = window.innerWidth;
        gameData.current.height = window.innerHeight;
        canvas.width = gameData.current.width;
        canvas.height = gameData.current.height;
        const shift = (gameData.current.width - oldW) / 2;
        blocks.forEach(b => b.x += shift);
        if (currentBlock) currentBlock.x += shift;
        gameData.current.stackCenterOfMass += shift;
      }

      ctx.clearRect(0, 0, width, height);

      // Draw City Background
      ctx.fillStyle = '#f1f5f9';
      const cityYOffset = height - 300 + cameraY * 0.2;
      cityBuildings.forEach((b) => ctx.fillRect(b.x, cityYOffset + (300 - b.h), b.w, b.h));

      ctx.save();
      
      // Screen Shake
      if (shake > 0) {
        ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
        gameData.current.shake *= 0.9;
      }

      // Unstable Sway
      if (score > 5) {
        const time = Date.now();
        const angle = Math.sin(time * 0.002) * Math.min(score * 0.002, 0.05);
        ctx.translate(width / 2, height / 2);
        ctx.rotate(angle);
        ctx.translate(-width / 2, -height / 2);
      }

      // Physics / Audio Update
      if (gameState === 'PLAYING' || gameState === 'DROPPING') {
        if (checkClap()) triggerDrop();

        if (gameState === 'PLAYING' && currentBlock) {
          currentBlock.updateSwing(width);
          currentBlock.y = blocks[blocks.length - 1].y - 200;
        } else if (gameState === 'DROPPING' && currentBlock) {
          currentBlock.y += GRAVITY;
          const prev = blocks[blocks.length - 1];
          if (currentBlock.y + currentBlock.h >= prev.y) {
            const result = handleLanding();
            if (result === 'MISS') {
              if (currentBlock.y > height + 100) {
                gameData.current.shake = 15;
                playSound('miss');
                setLives(l => {
                  const newL = l - 1;
                  if (newL <= 0) {
                    setGameOverMsg("You missed the tower!");
                    setGameState('GAMEOVER');
                  } else {
                    checkTurnEnd();
                  }
                  return newL;
                });
              }
            } else if (result === 'TOPPLE') {
              currentBlock.angle += 0.1;
              currentBlock.x += currentBlock.x < width / 2 ? -5 : 5;
              if (currentBlock.y > height + 200) {
                playSound('miss');
                setGameOverMsg("The tower toppled over!");
                setGameState('GAMEOVER');
              }
            } else {
              if (result === 'PERFECT') {
                playSound('perfect');
                confetti({
                  particleCount: 40,
                  spread: 60,
                  origin: { x: (currentBlock.x + blockWidth / 2) / width, y: (currentBlock.y - cameraY) / height },
                  colors: ['#0ea5e9', '#f43f5e', '#fbbf24']
                });
              } else {
                  playSound('land');
              }
              blocks.push(currentBlock);
              setScore(s => s + 1);
              checkTurnEnd();
            }
          }
        }
      }

      // Camera Follow
      const last = blocks[blocks.length - 1];
      const targetCameraY = score > 2 ? last.y - height * 0.6 : 0;
      gameData.current.cameraY += (targetCameraY - gameData.current.cameraY) * 0.1;

      // Draw Crane Line
      if (gameState === 'PLAYING' && currentBlock) {
        ctx.beginPath();
        ctx.moveTo(currentBlock.x + currentBlock.w / 2, -1000);
        ctx.lineTo(currentBlock.x + currentBlock.w / 2, currentBlock.y - cameraY);
        ctx.strokeStyle = 'rgba(0,0,0, 0.2)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      blocks.forEach((b) => b.draw(ctx, gameData.current.cameraY));
      if (gameState !== 'GAMEOVER' && currentBlock) {
        currentBlock.draw(ctx, gameData.current.cameraY);
      }

      ctx.restore();
      requestRef.current = requestAnimationFrame(loop);
    };

    // Initial City Generation
    const count = Math.ceil(window.innerWidth / 60);
    gameData.current.cityBuildings = Array.from({ length: count }, (_, i) => ({
      x: i * 60 + Math.random() * 20,
      w: 40 + Math.random() * 40,
      h: 100 + Math.random() * 200,
    }));

    requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [gameState, score, checkClap, triggerDrop, handleLanding, checkTurnEnd]);

  // --- Key Handlers ---
  useEffect(() => {
    const handleKey = (e) => {
      if (e.code === 'Space') triggerDrop();
    };
    window.addEventListener('keydown', handleKey);
    return () => window.removeEventListener('keydown', handleKey);
  }, [triggerDrop]);

  return (
    <div className="fixed inset-0 select-none overflow-hidden touch-none font-['Fredoka',sans-serif] bg-[#38bdf8]">
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap');
        body { font-family: 'Fredoka', sans-serif; }
      `}</style>

      {/* Background Gradient */}
      <div className="absolute inset-0 bg-gradient-to-b from-[#0ea5e9] via-[#bae6fd] to-[#f0f9ff]" />
      
      {/* Canvas */}
      <canvas 
        ref={canvasRef} 
        onMouseDown={(e) => {
          if (!e.target.closest('.ui-interactive')) triggerDrop();
        }}
        className="absolute inset-0 z-0" 
      />

      {/* HUD */}
      {gameState !== 'START' && gameState !== 'GAMEOVER' && (
        <div className="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-20 pointer-events-none">
          <div className="flex flex-col gap-3 pointer-events-auto ui-interactive">
            <button 
              onClick={() => setGameState('START')} 
              className="bg-white/90 hover:bg-white text-slate-700 font-bold p-3 rounded-xl shadow-lg border border-slate-200 transition-transform hover:scale-105 active:scale-95 flex items-center justify-center w-12 h-12"
            >
              üè†
            </button>

            <div className="bg-white/90 backdrop-blur rounded-xl px-4 py-2 flex flex-col justify-center min-w-[100px] shadow-lg border border-slate-200">
              <span className="text-[10px] uppercase text-slate-500 font-bold tracking-widest">Floors</span>
              <div className="text-4xl font-black text-sky-600 leading-none">{score}</div>
            </div>

            {gameMode === 'MULTI' && (
              <div className="bg-orange-50/90 backdrop-blur rounded-xl px-4 py-2 w-36 border border-orange-200 shadow-lg">
                <div className="text-[10px] uppercase text-slate-500 font-bold mb-1">Current Turn</div>
                <div className="flex items-center gap-2">
                  <span className="text-xl">{currentPlayer === 1 ? 'üî¥' : 'üîµ'}</span>
                  <span className={`font-bold ${currentPlayer === 1 ? 'text-red-500' : 'text-sky-500'}`}>Player {currentPlayer}</span>
                </div>
                <div className="text-xs text-slate-400 mt-1 font-bold">Moves: <span className="text-slate-600">{3 - movesInTurn}</span>/3</div>
              </div>
            )}
          </div>

          <div className="flex flex-col items-end gap-3 pointer-events-auto ui-interactive">
            <div className="bg-white/90 backdrop-blur rounded-xl px-4 py-2 shadow-lg border border-slate-200">
              <div className="flex gap-1">
                {Array.from({ length: maxLives }).map((_, i) => (
                  <span key={i} className={`text-2xl transition-all duration-300 ${i < lives ? '' : 'grayscale opacity-30 scale-75'}`}>
                    ‚ù§Ô∏è
                  </span>
                ))}
              </div>
            </div>

            <div className="bg-white/90 backdrop-blur rounded-xl px-3 py-2 flex items-center gap-2 shadow-lg border border-slate-200">
              <div className={`text-xl ${volumeLevel > (100 - micSensitivity) ? 'scale-125' : ''} transition-transform`}>üé§</div>
              <div className="w-24 h-4 bg-slate-200 rounded-full overflow-hidden relative border border-slate-300">
                <div 
                  className="absolute top-0 bottom-0 w-1 bg-amber-400 z-10 shadow-sm"
                  style={{ left: `${100 - micSensitivity}%` }}
                />
                <div 
                  className="h-full bg-sky-500 transition-all duration-75"
                  style={{ width: `${volumeLevel}%` }}
                />
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Start Screen */}
      {gameState === 'START' && (
        <div className="absolute inset-0 z-30 flex items-center justify-center bg-white/30 backdrop-blur-sm p-4 overflow-y-auto">
          <div className="max-w-4xl w-full bg-white p-6 rounded-3xl shadow-2xl border-4 border-sky-100 flex flex-col md:flex-row gap-6 items-stretch ui-interactive">
            <div className="flex-1 flex flex-col items-center justify-between text-center">
              <div>
                <h1 className="text-5xl font-black text-sky-500 mb-2 drop-shadow-sm tracking-tight">
                  TOWER<br /><span className="text-slate-700">CITY</span>
                </h1>
                <p className="text-base text-slate-500 mb-4 font-bold">Balance Builder</p>
                <div className="bg-sky-50 rounded-xl p-3 border-2 border-sky-100 mb-4 w-full">
                  <div className="flex items-center justify-center gap-3 mb-2">
                    <div className="text-3xl">üèóÔ∏è</div>
                    <div className="text-xl text-slate-300">‚ûú</div>
                    <div className="text-3xl animate-bounce">üëè</div>
                  </div>
                  <p className="text-slate-600 text-xs leading-relaxed font-medium">
                    <strong>CLAP</strong> or <strong>SPACE</strong> to drop blocks.<br />
                    Stack high, don't topple!
                  </p>
                </div>
              </div>
              <div className="w-full max-w-xs mb-4">
                <label className="flex justify-between text-slate-400 text-[10px] font-bold mb-1 uppercase px-1">
                  <span>Mic Sensitivity</span>
                  <span>{micSensitivity}%</span>
                </label>
                <input 
                  type="range" 
                  min="10" max="90" 
                  value={micSensitivity} 
                  onChange={(e) => setMicSensitivity(e.target.value)}
                  className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-sky-500"
                />
              </div>
            </div>

            <div className="w-px bg-slate-200 hidden md:block" />

            <div className="flex-1 w-full flex flex-col gap-4">
              <div>
                <h3 className="text-slate-700 font-black text-sm mb-2 uppercase tracking-wider text-left">1. Game Mode</h3>
                <div className="grid grid-cols-2 gap-3">
                  <button 
                    onClick={() => setGameMode('SOLO')}
                    className={`p-3 rounded-xl border-2 transition-all ${gameMode === 'SOLO' ? 'border-sky-500 bg-sky-50' : 'border-slate-100 bg-white'}`}
                  >
                    <div className="text-2xl mb-1">üë§</div>
                    <div className="font-bold text-slate-800 text-sm">Solo</div>
                  </button>
                  <button 
                    onClick={() => setGameMode('MULTI')}
                    className={`p-3 rounded-xl border-2 transition-all ${gameMode === 'MULTI' ? 'border-sky-500 bg-sky-50' : 'border-slate-100 bg-white'}`}
                  >
                    <div className="text-2xl mb-1">üë•</div>
                    <div className="font-bold text-slate-800 text-sm">Pass & Play</div>
                  </button>
                </div>
              </div>

              <div>
                <h3 className="text-slate-700 font-black text-sm mb-2 uppercase tracking-wider text-left">2. Difficulty</h3>
                <div className="flex bg-slate-100 p-1 rounded-xl">
                  {['EASY', 'NORMAL'].map((d) => (
                    <button 
                      key={d}
                      onClick={() => setDifficulty(d)}
                      className={`flex-1 py-2 rounded-lg text-xs font-bold transition-all ${difficulty === d ? 'bg-white shadow text-sky-600' : 'text-slate-500'}`}
                    >
                      {d === 'EASY' ? 'Easy (Wide)' : 'Normal'}
                    </button>
                  ))}
                </div>
              </div>

              <div className="bg-slate-50 p-3 rounded-xl border border-slate-200">
                <label className="flex justify-between text-slate-500 text-[10px] font-bold mb-2 uppercase px-1">
                  <span>Lives: <span className="text-sky-600 text-lg">{maxLives}</span></span>
                </label>
                <input 
                  type="range" min="1" max="5" 
                  value={maxLives} 
                  onChange={(e) => setMaxLives(parseInt(e.target.value))}
                  className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-sky-500"
                />
              </div>

              <button 
                onClick={startGame}
                className="w-full bg-sky-500 hover:bg-sky-600 text-white font-black text-xl py-3 rounded-xl shadow-lg transition-all transform hover:scale-105 active:scale-95 mt-auto"
              >
                START BUILDING
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Turn Change Modal */}
      {gameState === 'PAUSED' && (
        <div className="absolute inset-0 z-40 flex items-center justify-center bg-slate-900/90 backdrop-blur-md p-4">
          <div className="text-center bg-white p-8 rounded-3xl shadow-2xl max-w-sm w-full border-4 border-white animate-[bounce_3s_infinite]">
            <h2 className="text-2xl font-bold text-slate-400 mb-2 uppercase tracking-widest">Next Turn</h2>
            <div className="text-6xl mb-4">{currentPlayer === 1 ? 'üîµ' : 'üî¥'}</div>
            <h3 className={`text-4xl font-black mb-6 ${currentPlayer === 1 ? 'text-sky-500' : 'text-red-500'}`}>
              Player {currentPlayer === 1 ? 2 : 1}
            </h3>
            <p className="text-slate-500 mb-8">Pass the device to the next player!</p>
            <button 
              onClick={() => {
                setCurrentPlayer(p => p === 1 ? 2 : 1);
                setMovesInTurn(0);
                setGameState('PLAYING');
                spawnBlock();
              }}
              className="w-full py-4 bg-emerald-500 hover:bg-emerald-600 text-white font-bold text-xl rounded-xl shadow-lg transition-transform hover:scale-105 active:scale-95"
            >
              I'm Ready!
            </button>
          </div>
        </div>
      )}

      {/* Game Over Screen */}
      {gameState === 'GAMEOVER' && (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-slate-900/80 backdrop-blur-md p-4">
          <div className="text-center bg-white p-8 rounded-3xl shadow-2xl max-w-sm w-full border-4 border-slate-200 ui-interactive">
            <div className="text-6xl mb-4">üèöÔ∏è</div>
            <h2 className="text-4xl font-black text-slate-800 mb-2">CRUMBLED!</h2>
            <p className="text-slate-500 mb-6 font-medium">{gameOverMsg}</p>
            
            <div className="bg-slate-100 rounded-xl p-4 mb-6">
              <div className="text-[10px] uppercase text-slate-400 font-bold mb-1">Final Height</div>
              <div className="text-6xl font-black text-sky-500">{score}</div>
            </div>

            <div className="flex gap-3">
              <button 
                onClick={() => setGameState('START')} 
                className="flex-1 py-3 bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold rounded-xl transition-colors"
              >
                Home
              </button>
              <button 
                onClick={startGame} 
                className="flex-1 py-3 bg-sky-500 hover:bg-sky-600 text-white font-bold rounded-xl shadow-lg transition-transform hover:scale-105 active:scale-95"
              >
                Retry
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
